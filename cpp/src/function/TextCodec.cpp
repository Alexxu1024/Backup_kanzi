/*
Copyright 2011-2017 Frederic Langlet
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
you may obtain a copy of the License at

                http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

#include <sstream>
#include "TextCodec.hpp"
#include "../IllegalArgumentException.hpp"

using namespace kanzi;

// 1024 of the most common English words with at least 2 chars.
// Each char is 6 bit encoded: 0 to 31. Add 32 to a letter starting a word (MSB).
// TheBeAndOfInToHaveItThatFor...
const byte TextCodec::DICT_EN_1024[] = {
    byte(0xCC), byte(0x71), byte(0x21), byte(0x12), byte(0x03), byte(0x43), byte(0xB8), byte(0x5A),
    byte(0x0D), byte(0xCC), byte(0xE9), byte(0xC0), byte(0x54), byte(0x4A), byte(0x13), byte(0xCC),
    byte(0x70), byte(0x13), byte(0x94), byte(0xE4), byte(0x78), byte(0x39), byte(0x49), byte(0xC4),
    byte(0xD8), byte(0x84), byte(0xC7), byte(0xB8), byte(0xDC), byte(0x80), byte(0x20), byte(0x3C),
    byte(0x80), byte(0x62), byte(0x04), byte(0xE1), byte(0x51), byte(0x3D), byte(0x84), byte(0x85),
    byte(0x89), byte(0xC0), byte(0x0F), byte(0x31), byte(0xC4), byte(0x62), byte(0x04), byte(0xB6),
    byte(0x39), byte(0x42), byte(0xC3), byte(0xD8), byte(0x73), byte(0xAE), byte(0x46), byte(0x20),
    byte(0x0D), byte(0xB0), byte(0x06), byte(0x23), byte(0x3B), byte(0x31), byte(0xC8), byte(0x4B),
    byte(0x60), byte(0x12), byte(0xA1), byte(0x2B), byte(0x14), byte(0x08), byte(0x78), byte(0x0D),
    byte(0x62), byte(0x54), byte(0x4E), byte(0x32), byte(0xD3), byte(0x93), byte(0xC8), byte(0x71),
    byte(0x36), byte(0x1C), byte(0x04), byte(0xF3), byte(0x1C), byte(0x42), byte(0x11), byte(0xB8),
    byte(0xB0), byte(0xE6), byte(0x11), byte(0x39), byte(0x88), byte(0x54), byte(0x49), byte(0xC0),
    byte(0x4A), byte(0x04), byte(0x44), byte(0x9C), byte(0x83), byte(0x27), byte(0x11), byte(0x18),
    byte(0x8E), byte(0x30), byte(0x4B), byte(0x18), byte(0xB9), byte(0x44), byte(0x76), byte(0x11),
    byte(0x11), byte(0x36), byte(0x20), byte(0xB2), byte(0xF2), byte(0x38), byte(0xC1), byte(0x21),
    byte(0x10), byte(0x20), byte(0x14), byte(0x48), byte(0x4C), byte(0xC7), byte(0x11), byte(0x11),
    byte(0x33), byte(0x1D), byte(0x13), byte(0x94), byte(0x18), byte(0x7C), byte(0xC4), byte(0x2C),
    byte(0xBD), byte(0x87), byte(0x10), byte(0xDD), byte(0x8E), byte(0x44), byte(0xAC), byte(0xC7),
    byte(0x10), byte(0xCE), byte(0x04), byte(0x4F), byte(0x43), byte(0xEE), byte(0x58), byte(0xDB),
    byte(0x94), byte(0x4E), byte(0x83), byte(0x53), byte(0x3A), byte(0x95), byte(0x12), byte(0x4E),
    byte(0x23), byte(0x94), byte(0x2C), byte(0x3B), byte(0x95), byte(0x11), byte(0x1D), byte(0x87),
    byte(0x20), byte(0x21), byte(0xF3), byte(0x1C), byte(0x83), byte(0x4A), byte(0x8C), byte(0x06),
    byte(0x36), byte(0x01), byte(0x8C), byte(0xC7), byte(0x00), byte(0xDA), byte(0xC8), byte(0x28),
    byte(0x4B), byte(0x93), byte(0x1C), byte(0x44), byte(0x67), byte(0x39), byte(0x6C), byte(0xC7),
    byte(0x10), byte(0xDA), byte(0x13), byte(0x4A), byte(0xF1), byte(0x0E), byte(0x3C), byte(0xB1),
    byte(0x33), byte(0x58), byte(0xEB), byte(0x0E), byte(0x44), byte(0x4C), byte(0xC7), byte(0x11),
    byte(0x21), byte(0x21), byte(0x10), byte(0x43), byte(0x6D), byte(0x39), byte(0x6D), byte(0x80),
    byte(0x35), byte(0x39), byte(0x48), byte(0x45), byte(0x24), byte(0xED), byte(0x11), byte(0x6D),
    byte(0x12), byte(0x13), byte(0x21), byte(0x04), byte(0xCC), byte(0x83), byte(0x04), byte(0xB0),
    byte(0x03), byte(0x6C), byte(0x00), byte(0xD6), byte(0x33), byte(0x1C), byte(0x83), byte(0x46),
    byte(0xB0), byte(0x02), byte(0x84), byte(0x9C), byte(0x44), byte(0x44), byte(0xD8), byte(0x42),
    byte(0xCB), byte(0xB8), byte(0xD2), byte(0xD8), byte(0x9C), byte(0x84), byte(0xB5), byte(0x11),
    byte(0x16), byte(0x20), byte(0x15), byte(0x31), byte(0x11), byte(0xD8), byte(0x84), byte(0xC7),
    byte(0x39), byte(0x44), byte(0xE0), byte(0x34), byte(0xE4), byte(0xC7), byte(0x11), byte(0x1B),
    byte(0x4E), byte(0x80), byte(0xB2), byte(0xE1), byte(0x10), byte(0xB2), byte(0x04), byte(0x54),
    byte(0x48), byte(0x44), byte(0x14), byte(0xE4), byte(0x44), byte(0xB8), byte(0x51), byte(0x73),
    byte(0x1C), byte(0xE5), byte(0x06), byte(0x1F), byte(0x23), byte(0xA0), byte(0x18), byte(0x02),
    byte(0x0D), byte(0x49), byte(0x3D), byte(0x87), byte(0x20), byte(0xB1), byte(0x2B), byte(0x01),
    byte(0x24), byte(0xF3), byte(0x38), byte(0xE8), byte(0xCE), byte(0x58), byte(0xDC), byte(0xCE),
    byte(0x0C), byte(0x06), byte(0x32), byte(0x00), byte(0xC1), byte(0x21), byte(0x00), byte(0x22),
    byte(0xB3), byte(0x00), byte(0xA1), byte(0x24), byte(0x00), byte(0x21), byte(0xE3), byte(0x20),
    byte(0x51), byte(0x44), byte(0x44), byte(0x43), byte(0x53), byte(0xD8), byte(0x71), byte(0x11),
    byte(0x12), byte(0x11), byte(0x13), byte(0x58), byte(0x41), byte(0x0D), byte(0xCC), byte(0x73),
    byte(0x92), byte(0x12), byte(0x45), byte(0x44), byte(0x37), byte(0x21), byte(0x04), byte(0x37),
    byte(0x43), byte(0x43), byte(0x11), byte(0x18), byte(0x01), byte(0x39), byte(0x44), byte(0xEE),
    byte(0x34), byte(0x48), byte(0x0B), byte(0x48), byte(0xE9), byte(0x40), byte(0x09), byte(0x3B),
    byte(0x14), byte(0x49), byte(0x38), byte(0x02), byte(0x4D), byte(0x40), byte(0x0B), byte(0x2D),
    byte(0x8B), byte(0xD1), byte(0x11), byte(0x51), byte(0x0D), byte(0x4E), byte(0x45), byte(0xCF),
    byte(0x10), byte(0x24), byte(0xE2), byte(0x38), byte(0xD4), byte(0xC0), byte(0x20), byte(0xD8),
    byte(0x8E), byte(0x34), byte(0x21), byte(0x11), byte(0x36), byte(0xC1), byte(0x32), byte(0x08),
    byte(0x73), byte(0x8E), byte(0x2F), byte(0x81), byte(0x00), byte(0x47), byte(0x32), byte(0x0F),
    byte(0xAC), byte(0x00), byte(0x63), byte(0x50), byte(0x49), byte(0x15), byte(0x11), byte(0x1C),
    byte(0xCE), byte(0x58), byte(0x04), byte(0x43), byte(0x98), byte(0x84), byte(0x4B), byte(0x94),
    byte(0x84), byte(0x4C), byte(0x98), byte(0xB0), byte(0x12), byte(0x4A), byte(0x60), byte(0x12),
    byte(0xA8), byte(0x41), byte(0x0F), byte(0xD8), byte(0xE4), byte(0x4B), byte(0x0F), byte(0x24),
    byte(0xC8), byte(0x2C), byte(0xBD), byte(0x84), byte(0x35), byte(0x3C), byte(0x87), byte(0x39),
    byte(0x42), byte(0xC3), byte(0xC8), byte(0xF1), byte(0x0D), byte(0x0F), byte(0x24), byte(0xC0),
    byte(0x18), byte(0x48), byte(0xCE), byte(0x09), byte(0x33), byte(0x91), byte(0xB0), byte(0x81),
    byte(0x87), byte(0x4E), byte(0x93), byte(0x81), byte(0x98), byte(0xE8), byte(0x8E), byte(0x35),
    byte(0x32), byte(0x0D), byte(0x50), byte(0x49), byte(0x15), byte(0x11), byte(0x16), byte(0x0E),
    byte(0x34), byte(0x4B), byte(0x44), byte(0x54), byte(0x44), byte(0x60), byte(0x35), byte(0x25),
    byte(0x84), byte(0x46), byte(0x51), byte(0x16), byte(0xB0), byte(0x40), byte(0x0D), byte(0x8C),
    byte(0x81), byte(0x45), byte(0x11), byte(0x11), byte(0x0D), byte(0x08), byte(0x4C), byte(0xC4),
    byte(0x34), byte(0x3B), byte(0x44), byte(0x10), byte(0x3A), byte(0xC4), byte(0x01), byte(0x51),
    byte(0x33), byte(0x45), byte(0x8B), byte(0x48), byte(0x08), byte(0x49), byte(0xCE), byte(0x2C),
    byte(0x3C), byte(0x8E), byte(0x30), byte(0x44), byte(0xC7), byte(0x20), byte(0xD1), byte(0xA0),
    byte(0x48), byte(0xAD), byte(0x80), byte(0x44), byte(0xCA), byte(0xC8), byte(0x3E), byte(0x23),
    byte(0x95), byte(0x11), byte(0x1A), byte(0x12), byte(0x49), byte(0x41), byte(0x27), byte(0x00),
    byte(0xF3), byte(0xC4), byte(0x37), byte(0x35), byte(0x11), byte(0x36), byte(0xB3), byte(0x8E),
    byte(0x2B), byte(0x25), byte(0x11), byte(0x12), byte(0x32), byte(0x12), byte(0x08), byte(0xE5),
    byte(0x44), byte(0x46), byte(0x52), byte(0x06), byte(0x1D), byte(0x3B), byte(0x00), byte(0x0E),
    byte(0x32), byte(0x11), byte(0x10), byte(0x24), byte(0xC8), byte(0x38), byte(0xD8), byte(0x06),
    byte(0x44), byte(0x41), byte(0x32), byte(0x38), byte(0xC1), byte(0x0E), byte(0x34), byte(0x49),
    byte(0x40), byte(0x20), byte(0xBC), byte(0x44), byte(0x48), byte(0xF1), byte(0x02), byte(0x4E),
    byte(0xD3), byte(0x93), byte(0x20), byte(0x21), byte(0x22), byte(0x1C), byte(0xE2), byte(0x02),
    byte(0x12), byte(0x11), byte(0x06), byte(0x20), byte(0xDC), byte(0xC7), byte(0x44), byte(0x41),
    byte(0x32), byte(0x61), byte(0x24), byte(0xC4), byte(0x32), byte(0xB1), byte(0x15), byte(0x10),
    byte(0xB9), byte(0x44), byte(0x10), byte(0xBB), byte(0x04), byte(0x11), byte(0x38), byte(0x8E),
    byte(0x30), byte(0xF0), byte(0x0D), byte(0x62), byte(0x13), byte(0x97), byte(0xC8), byte(0x73),
    byte(0x96), byte(0xBC), byte(0xB0), byte(0x18), byte(0xAC), byte(0x85), byte(0x44), byte(0xAC),
    byte(0x44), byte(0xD3), byte(0x11), byte(0x19), byte(0x06), byte(0x1A), byte(0xD5), byte(0x0C),
    byte(0x04), byte(0x44), byte(0x6E), byte(0x3C), byte(0x43), byte(0x6F), byte(0x44), byte(0xE0),
    byte(0x4B), byte(0x10), byte(0xC9), byte(0x40), byte(0x4E), byte(0x70), byte(0x0D), byte(0x0E),
    byte(0xC1), byte(0x00), byte(0x49), byte(0x44), byte(0x44), byte(0xC1), byte(0x41), byte(0x12),
    byte(0x4C), byte(0x83), byte(0x8D), byte(0x88), byte(0x02), byte(0xCB), byte(0xC4), byte(0x43),
    byte(0x04), byte(0x30), byte(0x11), byte(0x11), byte(0x88), byte(0x44), byte(0x53), byte(0x00),
    byte(0x83), byte(0x6F), byte(0x51), byte(0x3B), byte(0x44), byte(0x5D), byte(0x38), byte(0x87),
    byte(0x00), byte(0x84), byte(0x72), byte(0x4C), byte(0x04), byte(0x53), byte(0xC5), byte(0x43),
    byte(0x71), byte(0x00), byte(0x84), byte(0x84), byte(0x98), byte(0xE0), byte(0x0B), byte(0xC4),
    byte(0x40), byte(0x0B), byte(0x2D), byte(0x89), byte(0xCE), byte(0x30), byte(0x4C), byte(0xC4),
    byte(0x02), byte(0x20), byte(0x0D), byte(0x0C), byte(0x80), byte(0xC0), byte(0x4C), byte(0x4B),
    byte(0x0E), byte(0x34), byte(0x46), byte(0x21), byte(0x51), byte(0x22), byte(0x0D), byte(0x11),
    byte(0x24), byte(0xB8), byte(0x39), byte(0x43), byte(0x46), byte(0x98), byte(0xE3), byte(0x83),
    byte(0x88), byte(0xE5), byte(0x11), byte(0x4E), byte(0x52), byte(0x0D), byte(0x0E), byte(0xA3),
    byte(0x4E), byte(0x5A), byte(0xA2), byte(0x0D), byte(0x0E), byte(0x71), byte(0x0B), byte(0x3E),
    byte(0xD2), byte(0x06), byte(0x1D), byte(0x38), byte(0x87), byte(0x20), byte(0xB0), byte(0xEB),
    byte(0x39), byte(0x3E), byte(0x0E), byte(0x51), byte(0x1D), byte(0x12), byte(0x91), byte(0x81),
    byte(0x38), byte(0x11), byte(0x2D), byte(0x8E), byte(0x44), byte(0x38), byte(0x48), byte(0x4F),
    byte(0x50), byte(0x0D), byte(0xB0), byte(0xE3), byte(0x53), byte(0x1E), byte(0x70), byte(0x0B),
    byte(0x16), byte(0xB3), byte(0x96), byte(0xB0), byte(0x82), byte(0xCB), byte(0x20), byte(0xE3),
    byte(0x67), byte(0x20), byte(0x61), byte(0xEE), byte(0x44), byte(0x60), byte(0x0D), byte(0x21),
    byte(0x90), byte(0x13), byte(0x20), byte(0xE3), byte(0x71), byte(0x10), byte(0x39), byte(0x91),
    byte(0x10), byte(0x43), byte(0x61), byte(0x2D), byte(0x41), byte(0x36), byte(0x1C), byte(0x84),
    byte(0xC4), byte(0x84), byte(0xB0), byte(0x02), byte(0x2B), byte(0x83), byte(0x94), byte(0x45),
    byte(0x21), byte(0x0B), byte(0x16), byte(0x42), byte(0x06), byte(0x1D), byte(0x38), byte(0x4E),
    byte(0x4C), byte(0x7A), byte(0xC8), byte(0x4D), byte(0x32), byte(0xC4), byte(0x9C), byte(0xE5),
    byte(0x12), byte(0x12), byte(0xB1), byte(0x13), byte(0x8C), byte(0x44), byte(0x8F), byte(0x21),
    byte(0x31), byte(0x2F), byte(0x44), byte(0xE5), byte(0x48), byte(0x0C), byte(0x4C), byte(0x84),
    byte(0x45), byte(0x52), byte(0x02), byte(0x12), byte(0x72), byte(0x0C), byte(0x48), byte(0x42),
    byte(0xC5), byte(0x95), byte(0x12), byte(0x04), byte(0x34), byte(0x38), byte(0xC4), byte(0x48),
    byte(0x24), byte(0x48), byte(0x04), byte(0x49), byte(0x40), byte(0x4C), byte(0x71), byte(0x11),
    byte(0x8C), byte(0x45), byte(0x44), byte(0x2C), byte(0xE3), byte(0xCC), byte(0x10), byte(0xD4),
    byte(0xE0), byte(0x58), byte(0x06), byte(0x2A), byte(0x20), byte(0xB2), byte(0xF3), byte(0x44),
    byte(0x83), byte(0xE7), byte(0x39), byte(0x44), byte(0x66), byte(0x00), byte(0xC1), byte(0x2E),
    byte(0x15), byte(0x31), byte(0x0D), byte(0xBC), byte(0xB0), byte(0x0D), byte(0x4E), byte(0xF2),
    byte(0xC0), byte(0x08), byte(0x49), byte(0x0D), byte(0x0E), byte(0x03), byte(0x0E), byte(0x34),
    byte(0x6C), byte(0x88), byte(0x34), byte(0x21), byte(0x32), byte(0x4C), byte(0x03), byte(0x43),
    byte(0x8C), byte(0x44), byte(0x88), byte(0x18), byte(0xDB), byte(0xC0), byte(0x45), byte(0x32),
    byte(0x02), byte(0x50), byte(0xB0), byte(0x11), byte(0xC9), byte(0x40), byte(0xC3), byte(0x10),
    byte(0xD2), byte(0xD8), byte(0xB0), byte(0x43), byte(0x01), byte(0x11), byte(0x1B), byte(0xC0),
    byte(0x62), byte(0xB0), byte(0x16), byte(0x84), byte(0xE3), byte(0x8A), byte(0xC8), byte(0x82),
    byte(0xC4), byte(0x34), byte(0x21), byte(0x20), byte(0x2C), byte(0xC3), byte(0x92), byte(0x4E),
    byte(0x83), byte(0x42), byte(0x2D), byte(0x40), byte(0xC4), byte(0x80), byte(0x60), byte(0x08),
    byte(0x36), byte(0x42), byte(0x13), byte(0x1C), byte(0x44), byte(0x73), byte(0x38), byte(0xE2),
    byte(0xE5), byte(0x21), byte(0x51), byte(0x2E), byte(0x34), byte(0x21), byte(0x2B), byte(0x10),
    byte(0x04), byte(0x93), byte(0x91), byte(0x73), byte(0xCB), byte(0x00), byte(0x83), byte(0x68),
    byte(0x0C), byte(0x43), byte(0x53), byte(0x20), byte(0x56), byte(0x34), byte(0x35), byte(0x32),
    byte(0x0B), byte(0xC8), byte(0x84), byte(0xC4), byte(0xB0), byte(0x83), byte(0x54), byte(0x4C),
    byte(0x48), byte(0x8E), byte(0x50), byte(0xF2), byte(0xC4), byte(0xD8), byte(0x41), byte(0x0A),
    byte(0xB0), byte(0x04), byte(0xD3), byte(0x11), byte(0x18), byte(0x51), byte(0x20), byte(0xD1),
    byte(0xA3), byte(0x11), byte(0x30), byte(0x08), byte(0x2E), byte(0x83), byte(0x45), byte(0x39),
    byte(0x13), byte(0x00), byte(0x4C), byte(0x83), byte(0x8D), byte(0xB4), byte(0xE4), byte(0xC7),
    byte(0x20), byte(0xD1), byte(0xA0), byte(0x35), byte(0x84), byte(0xC7), byte(0x20), byte(0xD1),
    byte(0xA4), byte(0x54), byte(0x44), byte(0x58), byte(0x4C), byte(0x72), byte(0x0D), byte(0x1A),
    byte(0x01), byte(0x8E), byte(0xAC), byte(0x40), byte(0x03), byte(0xC8), byte(0xE3), byte(0x04),
    byte(0x4C), byte(0x83), byte(0x04), byte(0x4B), byte(0x43), byte(0x43), byte(0x11), byte(0x14),
    byte(0x93), byte(0x00), byte(0xD0), byte(0xF6), byte(0x1C), byte(0x44), byte(0xC7), byte(0x11),
    byte(0x1B), byte(0x40), byte(0x4D), byte(0x44), byte(0x44), byte(0xCC), byte(0xE1), byte(0x84),
    byte(0x4C), byte(0x71), byte(0x11), byte(0x94), byte(0xE2), byte(0xCB), byte(0x39), byte(0x6B),
    byte(0xC0), byte(0x44), byte(0x43), byte(0x53), byte(0xC9), byte(0x33), byte(0x8F), byte(0xA0),
    byte(0xD0), byte(0xC4), byte(0x10), byte(0x38), byte(0xC8), byte(0x14), byte(0x52), byte(0x02),
    byte(0x50), byte(0xB4), byte(0xEF), byte(0x50), byte(0x12), byte(0xC8), byte(0x0A), byte(0x02),
    byte(0xD1), byte(0x10), byte(0x00), byte(0xD8), byte(0xC8), byte(0xF1), byte(0x00), byte(0x2A),
    byte(0xC0), byte(0x08), byte(0x35), byte(0x30), byte(0x08), byte(0x37), byte(0x11), byte(0x0C),
    byte(0x00), byte(0x83), byte(0x67), byte(0x10), byte(0x04), byte(0x60), byte(0x2C), byte(0xB3),
    byte(0x96), byte(0xB0), byte(0x40), byte(0xC8), byte(0x02), byte(0xE1), byte(0x45), byte(0x20),
    byte(0x21), byte(0x21), byte(0x10), byte(0xD1), byte(0x05), byte(0x21), byte(0x38), byte(0xCE),
    byte(0x39), byte(0x19), byte(0xD4), byte(0x1A), byte(0xF1), byte(0x11), byte(0x48), byte(0xE3),
    byte(0x6B), byte(0x01), byte(0x31), byte(0x11), byte(0x8D), byte(0x44), byte(0x48), byte(0x34),
    byte(0x6D), byte(0x80), byte(0x46), byte(0x72), byte(0x12), byte(0x4C), byte(0xE4), byte(0x58),
    byte(0x81), byte(0x11), byte(0x94), byte(0x13), byte(0x62), byte(0x13), byte(0x1C), byte(0x83),
    byte(0x72), byte(0x11), byte(0x38), byte(0x11), byte(0x4C), byte(0x80), byte(0x8B), byte(0x13),
    byte(0x24), byte(0xC0), byte(0x4C), byte(0x83), byte(0x8D), byte(0xB0), byte(0xE4), byte(0x4D),
    byte(0x20), byte(0xD1), byte(0xB6), byte(0x00), byte(0xB2), byte(0xA4), byte(0x54), byte(0x43),
    byte(0x53), byte(0xD8), byte(0x83), byte(0x62), byte(0x1C), byte(0xE3), byte(0x92), byte(0x12),
    byte(0x11), byte(0x07), byte(0x01), byte(0x52), byte(0x0E), byte(0x47), byte(0x21), byte(0xCE),
    byte(0x39), byte(0x39), byte(0x48), byte(0x44), byte(0x49), byte(0x4E), byte(0x38), byte(0x3C),
    byte(0xC8), byte(0x4C), byte(0xB1), byte(0x20), byte(0x44), byte(0xE5), byte(0x0D), byte(0x0E),
    byte(0x02), byte(0x11), byte(0xCC), byte(0x40), byte(0x02), byte(0x1C), byte(0x44), byte(0x66),
    byte(0x00), byte(0xFC), byte(0x94), byte(0x04), byte(0x91), byte(0x02), byte(0x4E), byte(0x43),
    byte(0x4E), byte(0x50), byte(0x61), byte(0xEF), byte(0x44), byte(0xE5), byte(0x44), byte(0x80),
    byte(0x24), byte(0x4E), byte(0x49), byte(0x28), byte(0x0B), byte(0x4C), byte(0x73), byte(0x94),
    byte(0x18), byte(0x79), byte(0xC4), byte(0x00), byte(0x39), byte(0x4E), byte(0x39), byte(0x3C),
    byte(0x84), byte(0x08), byte(0xE3), byte(0x43), byte(0x84), byte(0xE6), byte(0x2C), byte(0x00),
    byte(0x83), byte(0x6B), byte(0x20), byte(0x48), byte(0x01), byte(0x2C), byte(0x48), byte(0x88),
    byte(0x54), byte(0x82), byte(0xF3), byte(0x00), byte(0x12), byte(0xC4), byte(0xAC), byte(0xE5),
    byte(0x44), byte(0xBD), byte(0x13), byte(0x82), byte(0x11), byte(0x24), byte(0xAE), byte(0x14),
    byte(0x51), byte(0x11), byte(0xC9), byte(0x35), byte(0x03), byte(0x10), byte(0xD4), byte(0xE2),
    byte(0x38), byte(0xD4), byte(0x88), byte(0x0C), byte(0x44), byte(0x60), byte(0x3C), byte(0xF1),
    byte(0x00), byte(0x47), byte(0x24), byte(0xD4), byte(0x0D), byte(0x88), byte(0x54), byte(0x62),
    byte(0xD1), byte(0x00), byte(0x44), byte(0xB6), byte(0x27), byte(0x50), byte(0xC0), byte(0x0D),
    byte(0x91), byte(0x52), byte(0x03), byte(0x10), byte(0xD0), byte(0x84), byte(0xCC), byte(0x45),
    byte(0xD3), byte(0xB0), byte(0x44), byte(0xC7), byte(0x38), byte(0x3A), byte(0x0D), byte(0x08),
    byte(0xB5), byte(0x03), byte(0x20), byte(0xD1), byte(0xB2), byte(0x10), byte(0xD0), byte(0xF1),
    byte(0x10), byte(0x02), byte(0xC8), byte(0x64), byte(0x4C), byte(0x84), byte(0x35), byte(0x21),
    byte(0x21), byte(0x50), byte(0x82), byte(0xC3), byte(0x88), byte(0xE3), byte(0x53), byte(0x44),
    byte(0xE2), byte(0xE0), byte(0x50), byte(0x32), byte(0x04), byte(0x34), byte(0x21), byte(0x32),
    byte(0x11), byte(0x51), byte(0x11), byte(0x00), byte(0xB8), byte(0x94), byte(0x4E), byte(0x23),
    byte(0x8B), byte(0x2C), byte(0x41), byte(0x84), byte(0xA0), byte(0xD4), byte(0xC4), byte(0x44),
    byte(0x44), byte(0x93), byte(0xC9), byte(0x40), byte(0x82), byte(0x11), byte(0x24), byte(0xB2),
    byte(0x3C), byte(0x40), byte(0x88), byte(0x00), byte(0xBC), byte(0x48), byte(0x48), byte(0xA9),
    byte(0x17), byte(0x3C), byte(0x44), byte(0x48), byte(0x10), byte(0xD0), byte(0x84), byte(0x84),
    byte(0x41), byte(0xC8), byte(0x34), byte(0x38), byte(0x44), byte(0x4D), byte(0x31), byte(0x11),
    byte(0xC4), byte(0x44), byte(0x94), byte(0x2D), byte(0x3C), byte(0xD1), byte(0x10), byte(0x04),
    byte(0xF2), byte(0x21), byte(0x7C), byte(0x44), byte(0x2C), byte(0x04), byte(0xC8), byte(0x38),
    byte(0xD4), byte(0x87), byte(0x20), byte(0xF8), byte(0x0D), byte(0x20), byte(0xC0), byte(0x0B),
    byte(0xA0), byte(0xC3), byte(0xD1), byte(0x39), byte(0x51), byte(0x27), byte(0x00), byte(0x84),
    byte(0x72), byte(0x4C), byte(0x06), byte(0x33), byte(0x38), byte(0xFC), byte(0x44), byte(0x0D),
    byte(0x40), byte(0x84), byte(0xBC), byte(0x44), byte(0x47), byte(0x00), byte(0xF4), byte(0xAB),
    byte(0x01), byte(0x31), byte(0x36), byte(0x44), byte(0x84), byte(0xC4), byte(0x46), byte(0xF2),
    byte(0x02), byte(0x2A), byte(0x42), byte(0xD2), byte(0x13), byte(0x22), byte(0x06), byte(0x34),
    byte(0x81), byte(0x48), byte(0x08), byte(0x03), byte(0x53), byte(0x88), byte(0x70), byte(0x0D),
    byte(0x08), byte(0x49), byte(0xCE), byte(0x4C), byte(0x42), byte(0xE6), byte(0x10), byte(0xD1),
    byte(0x11), byte(0x00), byte(0xBC), byte(0x4E), byte(0x08), byte(0xAC), byte(0x44), byte(0x41),
    byte(0x42), byte(0x11), byte(0x12), byte(0x02), byte(0xCE), byte(0x34), byte(0x69), byte(0x48),
    byte(0x4F), byte(0x31), byte(0xC4), byte(0x31), byte(0x21), byte(0x0B), byte(0x54), byte(0x44),
    byte(0xB1), byte(0x10), byte(0xF3), byte(0x91), byte(0x4E), byte(0x23), byte(0x8D), byte(0x0C),
    byte(0x84), byte(0xC8), byte(0x38), byte(0xDC), byte(0x44), byte(0x00), byte(0x21), byte(0xF3),
    byte(0x45), byte(0x44), byte(0xC7), byte(0x90), byte(0x51), byte(0x4E), byte(0x45), byte(0x38),
    byte(0xC4), byte(0x08), byte(0x80), byte(0xC4), byte(0xC4), byte(0x04), byte(0xC4), byte(0x90),
    byte(0x35), byte(0x02), byte(0x01), byte(0x32), byte(0x0E), byte(0x36), byte(0x53), byte(0x91),
    byte(0x08), byte(0x49), byte(0x80), byte(0x44), byte(0x31), byte(0x0D), byte(0x8D), byte(0x15),
    byte(0x06), byte(0xAC), byte(0x40), byte(0x03), byte(0x11), byte(0x1D), byte(0x4E), byte(0x20),
    byte(0x21), byte(0x30), byte(0x50), byte(0x84), byte(0xC4), byte(0xD8), byte(0x73), byte(0x8B),
    byte(0x13), byte(0x21), byte(0x04), byte(0x32), byte(0xC2), byte(0x0D), byte(0x0E), byte(0x52),
    byte(0x0D), byte(0x00), byte(0xB2), byte(0xD8), byte(0xC8), byte(0x84), byte(0x71), byte(0x11),
    byte(0x35), byte(0x11), byte(0x36), byte(0x54), byte(0x44), byte(0x13), byte(0x24), byte(0xCE),
    byte(0x45), byte(0x8C), byte(0x44), byte(0x48), byte(0xF3), byte(0x8D), byte(0x0E), byte(0xF5),
    byte(0x12), byte(0x1E), byte(0x00), byte(0x82), byte(0x39), byte(0x10), byte(0xC8), byte(0x34),
    byte(0x68), byte(0x51), byte(0x39), byte(0x31), byte(0xC4), byte(0x46), byte(0xB1), byte(0x00),
    byte(0x44), byte(0xDC), byte(0x8E), byte(0x36), byte(0x73), byte(0x8F), byte(0x12), byte(0x31),
    byte(0x15), byte(0x10), byte(0xB3), byte(0x8F), byte(0x94), byte(0x41), byte(0x0B), byte(0x20),
    byte(0xD1), byte(0xB1), byte(0x10), byte(0x00), byte(0xE2), byte(0x01), byte(0x14), byte(0x58),
    byte(0x8C), byte(0x84), byte(0x84), byte(0x01), byte(0x21), byte(0x31), byte(0x38), byte(0x00),
    byte(0xF5), byte(0x01), byte(0x12), byte(0x0E), byte(0x51), byte(0x28), byte(0x40), byte(0x2C),
    byte(0xB8), byte(0x80), byte(0x48), byte(0x4B), byte(0x8F), byte(0x11), byte(0x10), byte(0x13),
    byte(0x20), byte(0xE3), byte(0x62), byte(0x2C), byte(0xE4), byte(0x84), byte(0xD4), byte(0x84),
    byte(0x88), byte(0x4F), byte(0x11), byte(0x02), byte(0x10), byte(0x85), byte(0x44), byte(0x85),
    byte(0x42), byte(0x0B), byte(0x0C), byte(0x83), byte(0x46), byte(0xD4), byte(0x02), byte(0xD4),
    byte(0x13), byte(0x11), byte(0x12), byte(0x10), byte(0x04), byte(0x42), byte(0x1E), byte(0x55),
    byte(0x0B), byte(0x2E), byte(0xC3), byte(0x83), byte(0x10), byte(0xBA), byte(0x4E), byte(0x20),
    byte(0xDC), byte(0x84), byte(0x01), byte(0x23), byte(0x8D), byte(0xCC), byte(0x05), byte(0xE3),
    byte(0x21), byte(0x11), byte(0x02), byte(0x4C), byte(0xE4), byte(0x6F), byte(0x39), byte(0x22),
    byte(0x13), byte(0x20), byte(0xE3), byte(0x6F), byte(0x2C), byte(0x06), byte(0x04), byte(0x47),
    byte(0x23), byte(0xCE), byte(0x45), byte(0x39), byte(0x11), byte(0x44), byte(0xE4), byte(0x71),
    byte(0x10), byte(0x23), byte(0x91), byte(0x0F), byte(0x13), byte(0x96), byte(0x8C), byte(0x04),
    byte(0xC0), byte(0xBC), byte(0x03), byte(0xC4), byte(0x47), byte(0x31), byte(0xC4), byte(0x39),
    byte(0x16), byte(0x32), byte(0x3C), byte(0x00), byte(0x84), byte(0x91), byte(0x51), byte(0x11),
    byte(0x62), byte(0x53), byte(0x91), byte(0x33), byte(0x25), byte(0x0F), byte(0x3C), byte(0xE4),
    byte(0x53), byte(0x80), byte(0x24), byte(0xC8), byte(0x38), byte(0xDB), byte(0x85), byte(0x14),
    byte(0x80), byte(0x88), byte(0x00), byte(0xBD), byte(0x87), byte(0x39), byte(0x21), byte(0x28),
    byte(0x0C), byte(0x40), byte(0x27), byte(0x00), byte(0xF3), byte(0xD8), byte(0x9C), byte(0x40),
    byte(0x11), byte(0x4E), byte(0x11), byte(0x12), byte(0x4F), byte(0x31), byte(0x00), byte(0x32),
    byte(0xF4), byte(0x4E), byte(0x24), byte(0x40), byte(0x93), byte(0x9C), byte(0x84), byte(0xE1),
    byte(0x01), byte(0x21), byte(0x31), byte(0x10), byte(0xF4), byte(0x44), byte(0x48), byte(0x43),
    byte(0x53), byte(0xCC), byte(0xE5), byte(0x8D), byte(0xBD), byte(0x42), byte(0xCB), byte(0x85),
    byte(0x44), byte(0xAC), byte(0x00), byte(0xF8), byte(0xD1), byte(0x62), byte(0xC3), byte(0x8C),
    byte(0x88), byte(0x04), byte(0xE3), byte(0x00), byte(0x3C), byte(0x4E), byte(0x38), byte(0xCC),
    byte(0x8C), byte(0x20), byte(0xB1), byte(0x25), byte(0x20), byte(0x42), byte(0xC3), byte(0xA0),
    byte(0xC3), byte(0xC0), byte(0x09), byte(0x39), byte(0x54), byte(0x34), byte(0x3A), byte(0xC0),
    byte(0x44), byte(0x61), byte(0x23), byte(0x38), byte(0x69), byte(0xD4), byte(0x18), byte(0x4B),
    byte(0xD1), byte(0x10), byte(0xF0), byte(0x11), byte(0x12), byte(0x43), byte(0x55), byte(0x21),
    byte(0x13), byte(0x8D), byte(0x30), byte(0x43), byte(0x53), byte(0x00), byte(0xBB), byte(0xD1),
    byte(0x38), byte(0x35), byte(0x02), byte(0x12), byte(0x71), byte(0x11), byte(0x48), byte(0x42),
    byte(0xC5), byte(0xCC), byte(0x40), byte(0x02), byte(0x1E), byte(0xE2), byte(0x0B), byte(0xC9),
    byte(0x40), byte(0x87), byte(0xC8), byte(0x84), byte(0xD4), byte(0x01), byte(0x32), byte(0x0E),
    byte(0x37), byte(0x32), byte(0x04), byte(0x88), byte(0xE4), byte(0x93), byte(0xA0), byte(0xD0),
    byte(0xD4), byte(0x49), byte(0x34), byte(0x58), byte(0xC8), byte(0xA2), byte(0x0D), byte(0xC9),
    byte(0x34), byte(0x44), byte(0x11), byte(0x3A), byte(0x0C), byte(0x00), byte(0x61), byte(0x28),
    byte(0x4D), byte(0x21), byte(0x0B), byte(0x16), byte(0xF1), byte(0xCE), byte(0x34), byte(0x4B),
    byte(0xD1), byte(0x20), byte(0x21), byte(0x36), byte(0x10), byte(0x04), byte(0x6C), byte(0x39),
    byte(0x24), byte(0xF2), byte(0x50), byte(0xDC), byte(0x8E), byte(0x38), byte(0xD8), byte(0x8B),
    byte(0x10), byte(0x04), byte(0x6F), byte(0x44), byte(0x00), byte(0x93), byte(0x20), byte(0x21),
    byte(0x2F), byte(0x20), byte(0x40), byte(0x84), byte(0xD8), byte(0x02), byte(0x13), byte(0xC4),
    byte(0x40), byte(0x84), byte(0x35), byte(0x3A), byte(0x0C), byte(0x3C), byte(0xE4), byte(0x53),
    byte(0x00), byte(0xD4), byte(0xEF), byte(0x44), byte(0xE0), byte(0xD4), byte(0x09), byte(0x3A),
    byte(0xC4), byte(0x15), byte(0x3D), byte(0x80), byte(0x2C), byte(0xBC), byte(0x84), byte(0x44),
    byte(0x81), byte(0x12), byte(0xB4), byte(0x45), byte(0x92), byte(0xC8), byte(0x70), byte(0x11),
    byte(0x12), byte(0xC3), byte(0x95), byte(0x20), byte(0x4A), byte(0x88), byte(0x0E), byte(0xD3),
    byte(0x91), byte(0xC8), byte(0x83), byte(0x0F), byte(0x2D), byte(0x8D), byte(0x88), byte(0x14),
    byte(0x4B), byte(0x8D), byte(0x4C), byte(0xE8), byte(0x80), byte(0x4C), byte(0x21), byte(0xEC),
    byte(0x61), byte(0x21), byte(0x0B), byte(0x16), byte(0x52), byte(0x0D), byte(0x12), byte(0x23),
    byte(0x8C), byte(0x3D), byte(0x44), byte(0xC4), byte(0x47), byte(0x23), byte(0x8D), byte(0x1A),
    byte(0x04), byte(0xD3), byte(0x10), byte(0xD4), byte(0xC8), byte(0x38), byte(0xD8), byte(0xD1),
    byte(0x01), byte(0x69), byte(0x48), byte(0x2C), byte(0xCC), byte(0x44), byte(0x3D), byte(0x40),
    byte(0x4B), byte(0x20), byte(0x20), byte(0x0D), byte(0xC8), byte(0x40), byte(0x94), byte(0x44),
    byte(0x84), byte(0xD8), byte(0xC8), byte(0x23), byte(0x91), byte(0x13), byte(0x31), byte(0x12),
    byte(0x4F), byte(0x24), byte(0xCE), byte(0x08), byte(0xAB), byte(0xCE), byte(0x48), byte(0x84),
    byte(0xC8), byte(0x54), byte(0x48), byte(0x80), byte(0x51), byte(0x21), byte(0x22), byte(0x10),
    byte(0xD4), byte(0xD4), byte(0x45), byte(0x8D), byte(0x88), byte(0x34), byte(0x33), byte(0x96),
    byte(0xB0), byte(0x43), byte(0x0E), byte(0x45), byte(0x89), byte(0x17), byte(0x21), byte(0x24),
    byte(0xEB), byte(0x21), byte(0x24), byte(0xC4), byte(0x37), byte(0x24), byte(0xD1), byte(0x00),
    byte(0x81), byte(0x87), byte(0x4E), byte(0x25), byte(0x0B), byte(0x4D), byte(0x44), byte(0x44),
    byte(0x84), byte(0x82), byte(0xCB), byte(0x20), byte(0xE3), byte(0x65), byte(0x39), byte(0x13),
    byte(0x04), byte(0x46), byte(0x31), byte(0x02), byte(0x21), byte(0x22), byte(0x0E), byte(0x36),
    byte(0x43), byte(0x44), byte(0x44), byte(0x66), byte(0x2C), byte(0x39), byte(0x51), byte(0x32),
    byte(0x50), byte(0xC3), byte(0x04), byte(0x47), byte(0x63), byte(0x8D), byte(0x0C), byte(0x44),
    byte(0x71), byte(0x10), byte(0xB0), byte(0x13), byte(0x12), byte(0x05), byte(0x40), byte(0x20),
    byte(0xB0), byte(0x01), byte(0x2C), byte(0x4A), byte(0xC8), byte(0x34), byte(0x4A), byte(0xC8),
    byte(0x28), byte(0x42), byte(0xD8), byte(0xB9), byte(0x44), byte(0xD2), byte(0x20), byte(0x31),
    byte(0x32), byte(0x1C), byte(0xE4), byte(0xF2), byte(0x1C), byte(0xE4), byte(0x53), byte(0x88),
    byte(0xE5), byte(0x0D), byte(0x4D), byte(0x16), byte(0x31), byte(0x38), byte(0xB1), byte(0x20),
    byte(0x44), byte(0x40), byte(0x32), byte(0x20), byte(0xD1), byte(0x8B), byte(0x13), byte(0x15),
    byte(0x0B), byte(0x12), byte(0x30), byte(0x14), byte(0x18), byte(0x74), byte(0xC4), byte(0x46),
    byte(0xC0), byte(0x11), byte(0x28), byte(0x44), byte(0xE8), byte(0x34), byte(0x32), byte(0x02),
    byte(0x01), byte(0x31), byte(0x2F), byte(0x44), byte(0x44), byte(0x84), byte(0x35), byte(0x3A),
    byte(0xC0), byte(0x34), byte(0x38), byte(0x80), byte(0x30), byte(0xF0), byte(0x08), byte(0x18),
    byte(0xDB), byte(0x00), byte(0x4C), byte(0x44), byte(0x48), byte(0x00), byte(0xBB), byte(0xCE),
    byte(0x3D), byte(0x42), byte(0xC0), byte(0x4C), byte(0x83), byte(0x8D), byte(0x90), byte(0x23),
    byte(0x8D), byte(0x38), byte(0xC6), byte(0x2C), byte(0x10), byte(0x32), byte(0x02), byte(0x00),
    byte(0xB9), byte(0xCE), byte(0x48), byte(0xF2), byte(0x13), byte(0x00), byte(0xB8), byte(0x87),
    byte(0x51), byte(0x10), byte(0x87), byte(0x99), byte(0x13), byte(0x94), byte(0x34), byte(0x3C),
    byte(0xC7), byte(0x39), byte(0x44), byte(0x80), byte(0x34), byte(0x38), byte(0x14), byte(0x4C),
    byte(0x73), byte(0x91), byte(0x21), byte(0x36), byte(0x28), byte(0x35), byte(0x24), byte(0xC4),
    byte(0x00), byte(0x3C), byte(0x44), byte(0x08), byte(0x43), byte(0x53), byte(0x2D), byte(0x89),
    byte(0x54), byte(0x4D), byte(0x44), byte(0x44), byte(0xD9), byte(0x13), byte(0x8D), byte(0x1A),
    byte(0x83), byte(0x55), byte(0x38), byte(0xB5), byte(0x44), byte(0xAC), byte(0x81), byte(0x44),
    byte(0x9C), byte(0x42), byte(0x06), byte(0x1D), byte(0x3A), byte(0x0D), byte(0x09), byte(0x11),
    byte(0x00), byte(0x48), byte(0x4C), byte(0x48), byte(0x18), byte(0x74), byte(0xE1), byte(0x00),
    byte(0xD2), byte(0xA2), byte(0x50), byte(0xB4), byte(0xD4), byte(0x44), byte(0x02), byte(0xE2),
    byte(0x11), byte(0x14), byte(0xC0), byte(0x20), byte(0xD2), byte(0xD8), byte(0xD8), byte(0x44),
    byte(0x93), byte(0x91), byte(0x71), byte(0x02), byte(0x51), byte(0x32), byte(0x15), byte(0x12),
    byte(0x13), byte(0x80), byte(0x44), byte(0x3C), byte(0x84), byte(0x10), byte(0xAA), byte(0xCE),
    byte(0x34), byte(0x6B), byte(0x85), byte(0x14), byte(0x80), byte(0x84), byte(0x47), byte(0x24),
    byte(0xC0), byte(0x4C), byte(0x43), byte(0x04), byte(0x35), byte(0x3C), byte(0x44), byte(0x49),
    byte(0x38), byte(0x40), byte(0x62), byte(0x31), byte(0x00), byte(0x2F), byte(0x63), byte(0x91),
    byte(0x28), byte(0x44), byte(0x71), byte(0x11), byte(0x23), byte(0x94), byte(0x44), byte(0x21),
    byte(0x33), byte(0x1D), byte(0x13), byte(0x96), byte(0x94), byte(0xE4), byte(0x56), byte(0x01),
    byte(0x10), byte(0xEF), byte(0x38), byte(0xB2), byte(0x02), byte(0x63), byte(0x20), byte(0x88),
    byte(0x10), byte(0xD0), byte(0x84), byte(0x91), byte(0x81), byte(0x12), byte(0x84), byte(0x40),
    byte(0xE8), byte(0x4C), byte(0x43), byte(0x36), byte(0x10), byte(0x03), byte(0xCE), byte(0x36),
    byte(0x52), byte(0x0B), byte(0x2E), byte(0xF2), byte(0xC0), byte(0x36), byte(0xC2), byte(0x0B),
    byte(0x21), byte(0x30), byte(0x11), byte(0x62), byte(0x65), byte(0x0D), byte(0x9C), byte(0xE4),
    byte(0xE7), byte(0x10), byte(0x04), byte(0xE0), byte(0x0C), byte(0x34), byte(0x44), byte(0x49),
    byte(0x28), byte(0x8E), byte(0x2C), byte(0x39), byte(0x4E), byte(0x09), byte(0x44), byte(0xA5),
    byte(0x39), byte(0x11), byte(0x08), byte(0x18), byte(0xDC), byte(0xD1), byte(0x10), byte(0x04),
    byte(0xCC), byte(0x10), byte(0xD4), byte(0xE1), byte(0x2C), byte(0xE3), byte(0x83), byte(0xD0),
    byte(0xF3), byte(0x8D), byte(0x88), byte(0xE5), byte(0x11), byte(0x48), byte(0x4C), byte(0xC7),
    byte(0x21), byte(0x10), byte(0xF6), byte(0x01), byte(0x30), byte(0x87), byte(0x80), byte(0x51),
    byte(0x44), byte(0x09), byte(0x39), byte(0x00), byte(0x44), byte(0xB6), byte(0x32), byte(0x4C),
    byte(0xE4), byte(0x44), byte(0xCC), byte(0x75), byte(0x12), byte(0xC8), byte(0xE5), byte(0x0D),
    byte(0x0E), byte(0x45), byte(0x44), byte(0x45), byte(0x85), byte(0x87), byte(0x11), byte(0x11),
    byte(0x21), byte(0x00), byte(0x16), byte(0x20), byte(0x0C), byte(0xC2), byte(0x0D), byte(0x21),
    byte(0x24), byte(0xD1), byte(0x01), byte(0x32), byte(0x0E), byte(0x36), byte(0xC3), byte(0x94),
    byte(0x4C), byte(0x7B), byte(0xC0), byte(0x18), byte(0x49), byte(0x0D), byte(0x4C), byte(0x44),
    byte(0x6F), byte(0x44), byte(0xE0), byte(0x40), byte(0x04), byte(0xB6), byte(0x2F), byte(0x38),
    byte(0x83), byte(0x53), byte(0xC8), byte(0x40), byte(0x13), byte(0xB4), byte(0x04), byte(0xD4),
    byte(0x44), byte(0x02), byte(0xF1), byte(0x00), byte(0x21), byte(0x25), byte(0x01), byte(0x18),
    byte(0x87), byte(0x00), byte(0xB2), byte(0xC4), byte(0x34), byte(0x61), byte(0x2F), byte(0x01),
    byte(0x24), byte(0xA0), byte(0x3C), byte(0xF2), byte(0xD8), byte(0xB0), byte(0x02), byte(0x0B),
    byte(0xD1), byte(0x25), byte(0x00), byte(0x2C), byte(0xB6), byte(0x2C), byte(0x21), byte(0x7C),
    byte(0xCE), byte(0x50), byte(0x61), byte(0xE2), byte(0x2C), byte(0x40), byte(0x11), byte(0x2D),
    byte(0x89), byte(0x91), byte(0x39), byte(0x69), byte(0x40), byte(0x09), byte(0x33), byte(0x91),
    byte(0xC9), byte(0x30), byte(0x13), byte(0x12), byte(0xB3), byte(0x82), byte(0x00), byte(0xB9),
    byte(0x94), byte(0x62), byte(0x40), byte(0x12), byte(0x4F), byte(0x20), byte(0x15), byte(0x13),
    byte(0x23), byte(0x94), byte(0x4C), byte(0x7C), byte(0x82), byte(0x10), byte(0xD1), byte(0x2C),
    byte(0x39), byte(0x31), byte(0xC4), byte(0x46), byte(0x20), byte(0x11), byte(0x10), byte(0x44),
    byte(0x70), byte(0x50), byte(0x80), byte(0x8A), byte(0x2D), byte(0x88), byte(0x84), byte(0x35),
    byte(0x34), byte(0x40), byte(0x2E), byte(0x50), byte(0x02), byte(0x12), byte(0x80), byte(0x84),
    byte(0x80), byte(0x13), byte(0x95), byte(0x12), byte(0x11), byte(0x18), byte(0x38), byte(0xD0),
    byte(0xEF), byte(0x20), byte(0x24), byte(0xD4), byte(0x44), byte(0x4B), byte(0x44), byte(0x4D),
    byte(0x63), byte(0x91), byte(0x2A), byte(0xC0), byte(0x0D), byte(0x00), byte(0x61), byte(0x0C),
    byte(0x10), byte(0xD4), byte(0xE8), byte(0x34), byte(0x32), byte(0x15), byte(0x20), byte(0x35),
    byte(0x00), byte(0x2E), byte(0x50), byte(0x0D), byte(0xC8), byte(0x86), byte(0x44), byte(0xC8),
    byte(0xF1), byte(0x04), byte(0x0E), byte(0x15), byte(0x12), byte(0x63), byte(0x21), byte(0x11),
    byte(0x20), byte(0xE5), byte(0x12), byte(0xB8), byte(0x20), byte(0x94), byte(0x46), byte(0x00),
    byte(0xC3), byte(0xC4), byte(0x40), byte(0x03), byte(0x63), byte(0x22), byte(0x06), byte(0x36),
    byte(0x23), byte(0x8B), byte(0x2C), byte(0x40), byte(0x93), byte(0x20), byte(0xE3), byte(0x6B),
    byte(0x21), byte(0x24), byte(0xE0), byte(0x3C), byte(0xF4), byte(0x4E), byte(0x00), byte(0x21),
    byte(0xE2), byte(0x1C), byte(0x04), byte(0x46), byte(0x13), byte(0x05), byte(0x00), byte(0x2C),
    byte(0x84), byte(0xD8), byte(0xBD), byte(0x11), byte(0x12), byte(0x49), byte(0x44), byte(0x44),
    byte(0xD4), byte(0xE4), byte(0xC4), byte(0xB4), byte(0xE4), byte(0xC4), byte(0xBC), byte(0x04),
    byte(0x53), byte(0xC4), byte(0x40), byte(0x0B), byte(0xD8), byte(0x40), byte(0x62), byte(0x51),
    byte(0x14), byte(0x44), byte(0x35), byte(0x38), byte(0xC4), byte(0x4C), byte(0x44), byte(0x4C),
    byte(0x20), byte(0xD1), byte(0x33), byte(0x45), byte(0x41), byte(0x32), byte(0x00), byte(0x3D),
    byte(0x87), byte(0x01), byte(0x31), byte(0x15), byte(0x11), byte(0x18), byte(0x51), byte(0x10),
    byte(0x02), byte(0xB6), byte(0x39), byte(0x14), byte(0x58), byte(0x89), byte(0x43), byte(0xEF),
    byte(0x01), byte(0x14), byte(0xC8), byte(0x09), byte(0x42), byte(0xC0), byte(0x44), byte(0xB6),
    byte(0x20), byte(0x30), byte(0xE5), byte(0x0D), byte(0x4E), byte(0x00), byte(0x48), byte(0x2C),
    byte(0x84), byte(0xD8), byte(0x90), byte(0x04), byte(0xF1), byte(0x10), byte(0x23), byte(0x86),
    byte(0x34), byte(0x86), byte(0x44), byte(0xC8), byte(0x84), byte(0xE2), byte(0x1C), byte(0x04),
    byte(0x40), byte(0x09), byte(0x31), byte(0x11), byte(0xC8), byte(0xE3), byte(0x04), byte(0x04),
    byte(0xE0), byte(0xD8), byte(0xAC), byte(0xE4), byte(0x92), byte(0x8C), byte(0x41), byte(0x91),
    byte(0x10), byte(0x49), byte(0x05), byte(0x14), byte(0x40), byte(0x93), byte(0x81), byte(0x34),
    byte(0xC0), byte(0x08), byte(0xAC), byte(0x93), byte(0x00), byte(0x51), byte(0x6C), byte(0x20),
    byte(0x30), byte(0xCB), byte(0x13), byte(0x31), byte(0x0B), byte(0x11), byte(0x52), byte(0x12),
    byte(0x20), byte(0xE3), byte(0x76), byte(0x1D), byte(0x8A), byte(0xC4), byte(0x18), byte(0x02),
    byte(0xE2), byte(0x00), byte(0xF2), byte(0x13), byte(0x00), byte(0xBC), byte(0xD1), byte(0x00),
    byte(0x31), byte(0x24), byte(0x2C), byte(0x40), byte(0x93), byte(0x20), byte(0xE3), byte(0x64),
    byte(0x54), byte(0x44), byte(0x58), byte(0x04), byte(0xE0), byte(0xD8), byte(0x8D), byte(0x13),
    byte(0x8F), byte(0xB0), byte(0x02), byte(0x4E), byte(0x47), byte(0x52), byte(0x04), byte(0x5B),
    byte(0x24), byte(0xC0), byte(0x34), byte(0x30), byte(0x11), byte(0x0E), byte(0x12), byte(0x0B),
    byte(0x2E), byte(0x43), byte(0x0F), byte(0x2C), byte(0xE6), byte(0x04), byte(0x12), byte(0x32),
    byte(0x12), byte(0x09), byte(0x44), byte(0x92), byte(0x20), byte(0xE3), byte(0x6E), byte(0x3C),
    byte(0xF3), byte(0x91), byte(0x4D), byte(0x43), byte(0x48), byte(0x4D), byte(0x88), byte(0x0D),
    byte(0x00), byte(0xB6), byte(0x12), byte(0x21), byte(0x2C), byte(0xC4), byte(0x37), byte(0x25),
    byte(0x06), byte(0x18), byte(0x44), byte(0x93), byte(0xAC), byte(0x05), byte(0x98), byte(0x11),
    byte(0x19), byte(0xD4), byte(0x48), byte(0x10), byte(0x0D), byte(0x0F), byte(0x21), byte(0x02),
    byte(0x4C), byte(0x83), byte(0x8D), byte(0x84), byte(0x40), byte(0x8E), byte(0x30), byte(0x4C),
    byte(0x8A), byte(0x20), byte(0xB2), byte(0xF2), byte(0x21), byte(0x24), byte(0xC4), byte(0x47),
    byte(0x24), byte(0xD8), byte(0x2C), byte(0x48), byte(0x91), byte(0x20), byte(0xC1), byte(0x2F),
    byte(0x44), byte(0xE1), byte(0x91), byte(0x00), byte(0xC8), byte(0x8E), byte(0x30), byte(0xF0),
    byte(0x11), byte(0x12), byte(0x20), byte(0x0F), byte(0xB0), byte(0x84), byte(0x92), byte(0x84),
    byte(0x00), byte(0xF2), byte(0x39), byte(0x14), byte(0xF3), byte(0x44), byte(0x02), byte(0x0D),
    byte(0x20), byte(0xD1), byte(0xA4), byte(0x01), byte(0x26), byte(0x2D), byte(0x10), byte(0x04),
    byte(0x71), byte(0x10), byte(0x62), byte(0x0E), byte(0x37), byte(0x24), byte(0xD1), byte(0x01),
    byte(0x31), byte(0x06), byte(0x62), byte(0xF5), byte(0x11), byte(0x3C), byte(0xE4), byte(0x84),
    byte(0xBC), byte(0x44), byte(0x45), byte(0x39), byte(0x13), byte(0x33), byte(0x10), byte(0x21),
    byte(0xCD), byte(0x38), byte(0xB3), byte(0x86), byte(0x62), byte(0x40), byte(0x8E), byte(0x34),
    byte(0xE3), byte(0x08), byte(0x0A), byte(0x15), byte(0x03), byte(0x18), byte(0x44), byte(0xE4),
    byte(0x5C), byte(0x03), byte(0x0F), byte(0x2C), byte(0x48), byte(0x87), byte(0x10), byte(0x22),
    byte(0xA4), byte(0x35), byte(0x52), byte(0x11), byte(0x38), byte(0xD3), byte(0x04), byte(0x35),
    byte(0x3A), byte(0xC4), byte(0x1A), byte(0x30), byte(0x11), byte(0x2B), byte(0x31), byte(0x11),
    byte(0x33), byte(0x10), byte(0x13), byte(0x1C), byte(0x44), byte(0x6B), byte(0x01), byte(0x41),
    byte(0x87), byte(0x99), byte(0x41), byte(0x12), byte(0x4A), byte(0x20), byte(0x11), byte(0xAC),
    byte(0xE5), byte(0x84), byte(0x46), byte(0x70), byte(0x0D), byte(0x1A), byte(0xF0), byte(0x12),
    byte(0x4F), byte(0x23), byte(0x82), byte(0x20), byte(0x02), byte(0xE5), byte(0x39), byte(0x11),
    byte(0x84), byte(0x4E), byte(0x75), byte(0x0D), byte(0x0D), byte(0x11), byte(0x03), byte(0xC4),
    byte(0x43), byte(0x0E), byte(0x54), byte(0x4B), byte(0x00), byte(0x34), byte(0x01), byte(0x84),
    byte(0x46), byte(0x43), byte(0x49), byte(0x39), byte(0x89), byte(0x17), byte(0x00), byte(0x24),
    byte(0xCB), byte(0x62), byte(0x32), byte(0x04), byte(0x94), byte(0x83), byte(0x40), byte(0x2E),
    byte(0xC0), byte(0x18), byte(0x04), byte(0x49), byte(0xC4), byte(0x00), byte(0xB4), byte(0xC7),
    byte(0x94), byte(0xB3), byte(0x8E), byte(0x46), byte(0x21), byte(0xC0), byte(0x34), byte(0x61),
    byte(0x2B), byte(0x01), byte(0x8B), byte(0xCE), byte(0x39), byte(0x19), byte(0x54), byte(0x36),
    byte(0x44), byte(0x93), byte(0x00), byte(0x12), byte(0xC8), byte(0x48), byte(0x7C), byte(0xD1),
    byte(0x20), byte(0x02), byte(0xF2), byte(0x3D), byte(0x12), byte(0x0D), byte(0x1A), byte(0x32),
    byte(0x0D), byte(0x34), byte(0x44), byte(0x61), byte(0x20), byte(0x6C), byte(0xC7), byte(0x00),
    byte(0xD2), byte(0xAF), byte(0x44), byte(0xE4), byte(0xC4), byte(0x09), byte(0x38), byte(0x15),
    byte(0x38), byte(0x80), byte(0xE8), byte(0x30), byte(0x01), byte(0x88), byte(0x34), byte(0x4C),
    byte(0xCE), byte(0x34), byte(0x81), byte(0x87), byte(0x4F), byte(0x24), byte(0xC0), byte(0x46),
    byte(0x04), byte(0x4C), byte(0x94), byte(0x83), byte(0x48), byte(0x48), byte(0x7B), byte(0x14),
    byte(0x48), byte(0x80), byte(0xAE), byte(0x58), byte(0xD1), byte(0x11), byte(0x89), byte(0x16),
    byte(0x20), byte(0x45), byte(0x3B), byte(0xD1), byte(0x21), byte(0x50), byte(0x13), byte(0x12),
    byte(0xE4), byte(0xC7), byte(0x11), byte(0x14), byte(0xB2), byte(0x20), byte(0xC3), byte(0xCB),
    byte(0x12), byte(0xF3), byte(0x8F), byte(0x50), byte(0xB0), byte(0x11), byte(0xC4), byte(0x41),
    byte(0x4B), byte(0x10), byte(0x24), byte(0xE4), byte(0x48), byte(0xF1), byte(0x02), byte(0x20),
    byte(0x02), byte(0xCB), byte(0x63), byte(0x23), byte(0x00), byte(0x2C), byte(0xBA), byte(0xC8),
    byte(0x18), byte(0x74), byte(0xEC), byte(0x11), byte(0x24), byte(0x80), byte(0x18), byte(0x4C),
    byte(0x93), byte(0x10), byte(0xFA), byte(0x84), byte(0x62), byte(0xF1), byte(0x00), byte(0x08),
    byte(0x4B), byte(0xD1), byte(0x38), byte(0x64), byte(0x44), byte(0x49), byte(0x28), byte(0x40),
    byte(0x37), byte(0x22), byte(0x03), byte(0x12), byte(0x64), byte(0x44), byte(0x01), byte(0x39),
    byte(0x48), byte(0x5E), byte(0x83), byte(0x53), byte(0x11), byte(0x15), byte(0x48), byte(0x11),
    byte(0x6B), byte(0x00), byte(0x34), byte(0x01), byte(0x84), byte(0xB4), byte(0x04), byte(0xC8),
    byte(0x38), byte(0xD0), byte(0x0B), byte(0x94), byte(0x84), byte(0x87), byte(0xAC), byte(0xE4),
    byte(0x84), byte(0x88), byte(0x03), byte(0x04), byte(0x44), byte(0x08), byte(0xC8), byte(0x48),
    byte(0x25), byte(0x12), byte(0x4A), byte(0x44), byte(0x14), byte(0x00), byte(0xBD), byte(0x84),
    byte(0x20), byte(0x61), byte(0xD3), byte(0xBC), byte(0x44), byte(0x45), byte(0x39), byte(0x13),
    byte(0x00), byte(0x34), byte(0x21), byte(0x32), byte(0x11), byte(0x51), byte(0x0D), byte(0xD8),
    byte(0x04), byte(0xC4), byte(0x46), byte(0xF4), byte(0x4E), byte(0x0D), byte(0x40), byte(0x93),
    byte(0x20), byte(0xE3), byte(0x6F), byte(0x11), byte(0x14), byte(0x8E), byte(0x34), byte(0x02),
    byte(0xE2), byte(0x10), byte(0xB2), byte(0xEF), byte(0x39), byte(0x61), byte(0x11), byte(0x91),
    byte(0x51), byte(0x0D), byte(0x20), byte(0xD1), byte(0xA2), byte(0x38), byte(0xB3), byte(0x91),
    byte(0xA0), byte(0xD4), byte(0x88), byte(0x0C), byte(0x48), byte(0x40), byte(0x47), byte(0x43),
    byte(0x48), byte(0x4E), byte(0xB1), byte(0x12), byte(0x4A), byte(0x00), byte(0xD4), byte(0x2D),
    byte(0x3D), byte(0x88), byte(0x0C), byte(0x4C), byte(0x40), byte(0x34), byte(0x61), byte(0x2C),
    byte(0x10), byte(0xD4), byte(0xC8), byte(0x38), byte(0xD8), byte(0xC4), byte(0x10), byte(0xF9),
    byte(0x03), byte(0x18), byte(0x4C), byte(0x93), byte(0x44), byte(0xE3), byte(0x46), byte(0x9C),
    byte(0x04), byte(0x43), byte(0xCD), byte(0x13), byte(0x94), byte(0x04), byte(0xB1), byte(0x2D),
    byte(0x10), byte(0x21), byte(0x12), byte(0x48), byte(0x04), byte(0x58), byte(0xC8), byte(0x01),
    byte(0x44), byte(0x88), byte(0xE3), byte(0x0C), byte(0x38), byte(0xD9), byte(0x44), byte(0x01),
    byte(0x19), byte(0x40), byte(0x30), byte(0x82), byte(0xD8), byte(0xC8), byte(0x40), byte(0x23),
    byte(0x44), byte(0x40), byte(0x0C), byte(0x88), byte(0xE3), byte(0x45), byte(0x11), byte(0x11),
    byte(0x0D), byte(0x08), byte(0x4C), byte(0x44), byte(0x3C), byte(0xB6), byte(0x2F), byte(0x44),
    byte(0xE3), byte(0xC4), byte(0x45), byte(0x36), byte(0x2C), byte(0x10), byte(0x44), byte(0xC8),
    byte(0x34), byte(0x68), byte(0x0B), byte(0x58), byte(0x06), byte(0x12), byte(0xC9), byte(0x35),
    byte(0x05), byte(0x16), byte(0x01), byte(0x84), byte(0x34), byte(0x26), byte(0x23), byte(0x10),
    byte(0x04), byte(0xC7), byte(0x99), byte(0x13), byte(0x96), byte(0x4C), byte(0x7C), byte(0x84),
    byte(0x2C), byte(0xBC), byte(0x8E), byte(0x2C), byte(0x32), byte(0x04), byte(0x46), byte(0x00),
    byte(0x93), byte(0x9C), byte(0x40), byte(0x15), byte(0x63), byte(0x61), byte(0x13), byte(0x84),
    byte(0x01), byte(0xAC), byte(0x01), byte(0x14), byte(0x48), byte(0x00), byte(0x61), byte(0x23),
    byte(0x10), byte(0x00), byte(0xF2), byte(0x20), byte(0xD1), byte(0xB1), byte(0x21), byte(0x21),
    byte(0x23), byte(0x10), byte(0x20), byte(0x03), byte(0x13), byte(0x61), byte(0xCE), byte(0x32),
    byte(0x52), byte(0x06), byte(0x51), byte(0x11), byte(0x2F), byte(0x38), byte(0xB2), byte(0x02),
    byte(0x12), byte(0x13), byte(0x83), byte(0x62), byte(0xC0), byte(0x02), byte(0x1C), byte(0x83),
    byte(0x44), byte(0x88), byte(0x04), byte(0xC4), byte(0x18), byte(0xE4), byte(0x58), byte(0x80),
    byte(0x71), byte(0x00), byte(0x0E), byte(0x54), byte(0x4E), byte(0x35), byte(0x38), byte(0x80),
    byte(0x44), byte(0x4B), byte(0x91), byte(0x0C), byte(0x44), byte(0x71), byte(0x10), byte(0x02),
    byte(0xC8), byte(0x4D), byte(0x8B), byte(0xC0), byte(0x45), byte(0x33), byte(0x44), byte(0x47),
    byte(0x80), byte(0x11), byte(0x0E), byte(0x11), byte(0x00), byte(0x4F), byte(0x52), byte(0x0E),
    byte(0x2C), byte(0x43), byte(0x42), byte(0x13), byte(0x33), byte(0x93), byte(0x00), byte(0xB8),
    byte(0xC4), byte(0x14), byte(0x43), byte(0x52), byte(0x13), byte(0x64), byte(0x48), byte(0x4C),
    byte(0x48), byte(0x8E), byte(0x35), byte(0x25), byte(0x0C), byte(0x11), byte(0x18), byte(0x84),
    byte(0x35), byte(0x31), byte(0x11), byte(0x99), byte(0x13), byte(0x94), byte(0x3F), byte(0x31),
    byte(0xCE), byte(0x50), byte(0x61), byte(0xD3), byte(0xB0), byte(0xE0), byte(0xC4), byte(0x44),
    byte(0xDC), byte(0xC0), byte(0x48), byte(0xA8), byte(0x8E), byte(0x00), byte(0x21), byte(0xF1),
    byte(0x10), byte(0x04), byte(0x8E), byte(0x36), byte(0x01), byte(0x84), byte(0x94), byte(0x83),
    byte(0x46), byte(0x11), byte(0x1C), byte(0x8F), byte(0x10), byte(0x22), byte(0x05), byte(0x20),
    byte(0x28), byte(0x8E), byte(0x34), byte(0xD1), byte(0x02), byte(0x4C), byte(0x83), byte(0x8D),
    byte(0xD8), byte(0x84), byte(0x87), byte(0xC4), byte(0x44), byte(0x8F), byte(0x38), byte(0xD4),
    byte(0x84), byte(0xBD), byte(0x11), byte(0x13), byte(0x4D), byte(0x8B), byte(0x0E), byte(0x54),
    byte(0x43), byte(0x04), byte(0x35), byte(0x38), byte(0x80), byte(0x44), byte(0x3A), byte(0xCE),
    byte(0x1A), byte(0xF1), byte(0x0D), byte(0xC9), byte(0x43), byte(0x33), byte(0x44), byte(0x41),
    byte(0x24), byte(0x35), byte(0x32), byte(0x11), byte(0x12), byte(0x22), byte(0x13), byte(0x21),
    byte(0x91), byte(0x0D), byte(0xCC), byte(0x74), byte(0x4E), byte(0x50), byte(0x61), byte(0xCE),
    byte(0x51), byte(0x3B), byte(0xC4), byte(0x4F), byte(0x22), byte(0x0C), byte(0x20), byte(0xB0),
    byte(0x11), byte(0xD4), byte(0x80), byte(0x93), byte(0x20), byte(0xCB), byte(0x44), byte(0x59),
    byte(0x23), byte(0xC0), byte(0x3C), byte(0x44), byte(0x73), byte(0x1D), byte(0x11), byte(0x00),
    byte(0x4E), byte(0x22), byte(0xC0), byte(0x49), byte(0x2C), byte(0x87), byte(0x00), byte(0xA1),
    byte(0x32), byte(0x39), byte(0x44), byte(0x42), byte(0x12), byte(0x00), byte(0x82), byte(0x39),
    byte(0x43), byte(0x53), byte(0xBC), byte(0x02), byte(0x0D), byte(0x94), byte(0x02), byte(0xCB),
    byte(0xC4), byte(0x80), byte(0x87), byte(0xBC), byte(0xE4), byte(0x92), byte(0x20), byte(0x12),
    byte(0xC4), byte(0x80), byte(0x20), byte(0x84), byte(0x3D), byte(0x3C), byte(0x8E), byte(0x2C),
    byte(0x80), byte(0xF3), byte(0x44), byte(0x05), byte(0x44), byte(0x2F), byte(0x30), byte(0x0B),
    byte(0x2B), byte(0x22), byte(0x98), byte(0x89), byte(0x11), byte(0x00), byte(0x4C), byte(0x4B),
    byte(0x4E), byte(0x34), byte(0x4B), byte(0xCB), byte(0x10), byte(0xD4), byte(0xD8), byte(0xBC),
    byte(0x44), byte(0x48), byte(0x38), byte(0x38), byte(0xC4), byte(0x14), byte(0x83), byte(0x44),
    byte(0xB4), byte(0xE4), byte(0x4C), byte(0x00), byte(0xBC), byte(0x44), byte(0x54), byte(0x40),
    byte(0x0B), byte(0x8D), byte(0x12), byte(0x0D), byte(0x2A), byte(0x05), byte(0x13), byte(0x1C),
    byte(0xE4), byte(0x72), byte(0x11), byte(0x15), byte(0x44), byte(0xB4), byte(0x03), byte(0x04),
    byte(0xB0), byte(0xE3), byte(0x04), byte(0x35), byte(0x38), byte(0x06), byte(0x10), byte(0xD4),
    byte(0xE3), byte(0x38), byte(0x25), byte(0x0C), byte(0x10), byte(0xD4), byte(0xE0), byte(0x09),
    byte(0x32), byte(0x15), byte(0x21), byte(0x36), byte(0x20), byte(0x35), byte(0x85), byte(0x80),
    byte(0x62), byte(0x01), byte(0x51), byte(0x00), byte(0x80), byte(0xF3), byte(0x60), byte(0xF1),
    byte(0x20), byte(0x09), byte(0x32), byte(0x15), byte(0x13), byte(0x34), byte(0x40), byte(0x20),
    byte(0xDA), byte(0x0D), byte(0x4C), byte(0x44), byte(0x44), byte(0x49), byte(0x32), byte(0x0D),
    byte(0x1B), byte(0x10), byte(0x03), byte(0x20), byte(0xE8), byte(0xC0), byte(0x34), byte(0x61),
    byte(0x11), byte(0x98), byte(0x43), byte(0x44), byte(0x44), byte(0x04), byte(0xC8), byte(0x38),
    byte(0xDA), byte(0xC4), byte(0x00), byte(0x58), byte(0x8E), byte(0x3D), byte(0x8B), byte(0x00),
    byte(0x4C), byte(0x21), byte(0xE2), byte(0x2C), byte(0x02), byte(0x0C), byte(0x80), byte(0xD6),
    byte(0x0E), byte(0x34), byte(0x4C), byte(0x8E), byte(0x15), byte(0x35), byte(0x80), byte(0x44),
    byte(0x4B), byte(0xC0), byte(0x45), byte(0x36), byte(0x23), byte(0x11), byte(0x52), byte(0x02),
    byte(0x12), byte(0x23), byte(0x83), byte(0x12), byte(0xB0), byte(0x0D), byte(0x19), byte(0x40),
    byte(0x06), byte(0x12), byte(0xB2), byte(0x0D), byte(0x2A), byte(0x73), byte(0x96), byte(0x11),
    byte(0x51), byte(0x11), byte(0x88), byte(0xE3), byte(0x45), byte(0x21), byte(0x13), byte(0x22),
    byte(0x38), byte(0xC3), byte(0x04), byte(0x35), byte(0x38), byte(0x88), byte(0x4D), byte(0x88),
    byte(0x0D), byte(0x61), byte(0x61), byte(0xC4), byte(0x44), byte(0x4C), byte(0x8E), byte(0x30),
    byte(0x45), byte(0x84), byte(0x1C), byte(0x44), byte(0x44), byte(0x8C), byte(0x40), byte(0x40),
    byte(0x4C), byte(0x48), byte(0xD1), byte(0x21), byte(0x51), byte(0x27), byte(0x20), byte(0x61),
    byte(0xC4), byte(0x46), byte(0x11), byte(0x00), byte(0x51), byte(0x32), byte(0x05), byte(0x50),
    byte(0xBB), byte(0x8D), byte(0x2C), byte(0x83), byte(0x44), byte(0xD8), byte(0xE3), byte(0x00),
    byte(0x36), byte(0xF4), byte(0x48), byte(0x39), byte(0x12), byte(0x13), byte(0x63), byte(0x34),
    byte(0x40), byte(0x0C), byte(0x84), byte(0xC8), byte(0x38), byte(0xD0), byte(0x0B), byte(0x94),
    byte(0xE5), byte(0x11), byte(0x94), byte(0x83), byte(0x40), byte(0x34), byte(0x22), byte(0x00),
    byte(0x2D), byte(0xE7), byte(0x9E)
};

DictEntry TextCodec::STATIC_DICTIONARY[1024] = {};
const bool* TextCodec::DELIMITER_CHARS = TextCodec::initDelimiterChars();
const bool* TextCodec::TEXT_CHARS = TextCodec::initTextChars();
const int TextCodec::STATIC_DICT_WORDS = TextCodec::createDictionary(TextCodec::unpackDictionary32(DICT_EN_1024, sizeof(DICT_EN_1024)), STATIC_DICTIONARY, 1024, 0);

bool* TextCodec::initDelimiterChars()
{
    bool* res = new bool[256];

    for (int i = 0; i < 256; i++) {
        if ((i >= ' ') && (i <= '/')) // [ !"#$%&'()*+,-./]
            res[i] = true;
        else if ((i >= ':') && (i <= '?')) // [:;<=>?]
            res[i] = true;
        else {
            switch (i) {
            case '\n':
            case '\r':
            case '\t':
            case '_':
            case '|':
            case '{':
            case '}':
            case '[':
            case ']':
                res[i] = true;
                break;
            default:
                res[i] = false;
            }
        }
    }

    return res;
}

bool* TextCodec::initTextChars()
{
    bool* res = new bool[256];

    for (int i = 0; i < 256; i++) {
        res[i] = isUpperCase(byte(i)) | isLowerCase(byte(i));
    }

    return res;
}

// dictSize (in words) = number of dictionary entries
TextCodec::TextCodec(int dictSize)
{
    _logHashSize = LOG_HASHES_SIZE;
    _dictSize = dictSize;
    const int32 mapSize = 1 << _logHashSize;
    _dictMap = new DictEntry*[mapSize];
    _dictList = new DictEntry[_dictSize];
    _hashMask = mapSize - 1;
    int nbWords = STATIC_DICT_WORDS;
    memcpy(&_dictList[0], &STATIC_DICTIONARY[0], STATIC_DICT_WORDS * sizeof(DictEntry));

    // Add special entries at start of map
    _escapes[0] = ESCAPE_TOKEN2;
    _escapes[1] = ESCAPE_TOKEN1;
    _dictList[nbWords] = DictEntry(_escapes, 0, 0, nbWords, 1);
    _dictList[nbWords + 1] = DictEntry(_escapes, 1, 0, nbWords + 1, 1);
    _staticDictSize = nbWords + 2;
}

TextCodec::TextCodec(map<string, string>& ctx)
{
    map<string, string>::iterator it;
    it = ctx.find("size");
    const int blockSize = atoi(it->second.c_str());

    // Select an appropriate initial dictionary size
    int dSize = 1 << 12;

    for (int i = 14; i <= 24; i += 2) {
        if (blockSize >= 1 << i)
            dSize <<= 1;
    }

    _logHashSize = LOG_HASHES_SIZE;
    _dictSize = dSize;
    const int32 mapSize = 1 << _logHashSize;
    _dictMap = new DictEntry*[mapSize];
    _dictList = new DictEntry[_dictSize];
    _hashMask = mapSize - 1;
    int nbWords = STATIC_DICT_WORDS;
    memcpy(&_dictList[0], &STATIC_DICTIONARY[0], STATIC_DICT_WORDS * sizeof(DictEntry));

    // Add special entries at start of map
    _escapes[0] = ESCAPE_TOKEN2;
    _escapes[1] = ESCAPE_TOKEN1;
    _dictList[nbWords] = DictEntry(_escapes, 0, 0, nbWords, 1);
    _dictList[nbWords + 1] = DictEntry(_escapes, 1, 0, nbWords + 1, 1);
    _staticDictSize = nbWords + 2;
}

// dictSize (in words) = number of dictionary entries
TextCodec::TextCodec(int dictSize, byte dict[], int size, int logHashSize)
{
    if ((logHashSize < 10) || (logHashSize > 28))
        throw IllegalArgumentException("The hash table size log must be in [10..28]");

    if ((dictSize < STATIC_DICT_WORDS + 128) || (dictSize > (1 << logHashSize))) {
        stringstream ss;
        int hs = 1 << logHashSize;
        ss << "The number of words in the dictionary must be in [" << (STATIC_DICT_WORDS + 128) << ".." << hs << "]";
        throw IllegalArgumentException(ss.str());
    }

    _logHashSize = logHashSize;
    _dictSize = dictSize;
    const int32 mapSize = 1 << _logHashSize;
    _dictMap = new DictEntry*[mapSize];
    _dictList = new DictEntry[_dictSize];
    _hashMask = mapSize - 1;
    int nbWords;

    // Replace default dictionary ?
    if (dict != DICT_EN_1024) {
        // Keep at least 20% space for dynamic dictionary
        nbWords = TextCodec::createDictionary(SliceArray<byte>(dict, size, 0), _dictList, _dictSize * 4 / 5, 0);
    }
    else {
        int sz = sizeof(STATIC_DICTIONARY);

        if (sz > _dictSize)
            sz = _dictSize;

        memcpy(&_dictList[0], &STATIC_DICTIONARY[0], sz);
        nbWords = STATIC_DICT_WORDS;
    }

    // Add special entries at start of map
    _escapes[0] = ESCAPE_TOKEN2;
    _escapes[1] = ESCAPE_TOKEN1;
    _dictList[nbWords] = DictEntry(_escapes, 0, 0, nbWords, 1);
    _dictList[nbWords + 1] = DictEntry(_escapes, 1, 0, nbWords + 1, 1);
    _staticDictSize = nbWords + 2;
}

bool TextCodec::forward(SliceArray<byte>& input, SliceArray<byte>& output, int count)
{
    if ((!SliceArray<byte>::isValid(input)) || (!SliceArray<byte>::isValid(output)))
        return false;

    if (input._array == output._array)
        return false;

    if (output._length - output._index < getMaxEncodedLength(count))
        return false;

    byte* src = &input._array[input._index];
    byte* dst = &output._array[output._index];
    int srcIdx = 0;
    int dstIdx = 0;

    if (count <= 16) {
        for (int i = 0; i < count; i++)
            dst[dstIdx++] = src[srcIdx++];

        input._index += count;
        output._index += count;
        return true;
    }

    // Populate hash map
    const int32 mapSize = 1 << _logHashSize;

    for (int i = 0; i < mapSize; i++) {
        _dictMap[i] = nullptr;
    }

    for (int i = 0; i < _staticDictSize; i++) {
        _dictMap[_dictList[i]._hash & _hashMask] = &_dictList[i];
    }

    // Pre-allocate all dictionary entries
    for (int i = _staticDictSize; i < _dictSize; i++)
        _dictList[i] = DictEntry(nullptr, -1, 0, i, 0);

    const int srcEnd = count;
    const int dstEnd = getMaxEncodedLength(count);
    const int dstEnd3 = dstEnd - 3;
    int anchor = isText(src[srcIdx]) ? srcIdx - 1 : srcIdx; // previous delimiter
    int endWordIdx = ~anchor;
    int emitAnchor = 0; // never less than 0
    int words = _staticDictSize;
    int binCount = 0;
    int threshold = 8192;

    while ((srcIdx < srcEnd) && (dstIdx < dstEnd)) {
        byte cur = src[srcIdx];

        if (isText(cur)) {
            srcIdx++;
            continue;
        }

        bool mustEmit = emitAnchor < srcIdx;
        binCount += (uint8(cur) >> 7);

        if (((srcIdx > anchor + 2)) && (isDelimiter(cur) || (cur == ESCAPE_TOKEN1) || (cur == ESCAPE_TOKEN2))) // At least 2 letters
        {
            // Compute hashes
            // h1 -> hash of word chars
            // h2 -> hash of word chars with first char case flipped
            byte val = src[anchor + 1];
            const int caseFlag = isUpperCase(val) ? 32 : -32;
            int32 h1 = HASH1;
            int32 h2 = HASH1;
            h1 = h1 * HASH1 ^ int32(val) * HASH2;
            h2 = h2 * HASH1 ^ int32(val + caseFlag) * HASH2;

            for (int i = anchor + 2; i < srcIdx; i++) {
                const int h = int32(src[i]) * HASH2;
                h1 = h1 * HASH1 ^ h;
                h2 = h2 * HASH1 ^ h;
            }

            // Check word in dictionary
            const int length = srcIdx - anchor - 1;
            DictEntry* pe1 = _dictMap[h1 & _hashMask];
            DictEntry* pe2 = nullptr; // _dictMap[h2 & _hashMask];

            // Check for hash collisions
            if ((pe1 != nullptr) && ((pe1->_length != length) || (pe1->_hash != h1)))
                pe1 = nullptr;

            if (pe1 == nullptr) {
                pe2 = _dictMap[h2 & _hashMask];

                // Hash collision (quick check)  ?
                if ((pe2 != nullptr) && ((pe2->_length != length) || (pe2->_hash != h2)))
                    pe2 = nullptr;
            }

            DictEntry* pe = (pe2 == nullptr) ? pe1 : pe2;

            if (pe != nullptr) {
                if (!sameWords(&pe->_buf[pe->_pos + 1], &src[anchor + 2], length - 1))
                    pe = nullptr;
            }

            if (pe == nullptr) {
                // Word not found in the dictionary or hash collision: add or replace word
                if (((length > 3) || ((length > 2) && (words < THRESHOLD2))) && (length < MAX_WORD_LENGTH)) {
                    DictEntry* pe = &_dictList[words];
                    int peidx = int(pe->_idx);

                    if (peidx >= _staticDictSize) {
                        // Evict and reuse old entry
                        _dictMap[pe->_hash & _hashMask] = nullptr;
                        pe->_buf = src;
                        pe->_pos = anchor + 1;
                        pe->_hash = h1;
                        pe->_idx = int32(words);
                        pe->_length = int16(length);
                    }

                    // Update hash map
                    _dictMap[h1 & _hashMask] = pe;
                    words++;

                    // Dictionary full ? Expand or reset index to end of static dictionary
                    if (words >= _dictSize) {
                        if (expandDictionary() == false)
                            words = _staticDictSize;
                    }
                }
            }
            else {
                // Word found in the dictionary
                // Skip space if only delimiter between 2 word references
                if ((endWordIdx != anchor) || (src[emitAnchor] != ' '))
                    dstIdx += emitSymbols(&src[emitAnchor], &dst[dstIdx], anchor + 1 - emitAnchor, dstEnd - dstIdx);

                if (dstIdx >= dstEnd3)
                    break;

                dst[dstIdx++] = (pe == pe1) ? ESCAPE_TOKEN1 : ESCAPE_TOKEN2;
                dstIdx += emitWordIndex(&dst[dstIdx], pe->_idx);
                endWordIdx = srcIdx;
                mustEmit = false;
            }
        }

        if (mustEmit == true) {
            // Emit all symbols since last delimiter
            dstIdx += emitSymbols(&src[emitAnchor], &dst[dstIdx], srcIdx - emitAnchor, dstEnd - dstIdx);
        }

        if (srcIdx >= threshold) {
            // Early exit if input does not look like text
            if (4 * binCount >= srcIdx) {
                output._index += dstIdx;
                input._index += srcIdx;
                return false;
            }

            threshold += 8192;
        }

        // Reset delimiter position
        anchor = srcIdx;
        emitAnchor = anchor;
        srcIdx++;
    }

    // Emit last symbols
    dstIdx += emitSymbols(&src[emitAnchor], &dst[dstIdx], srcEnd - emitAnchor, dstEnd - dstIdx);

    output._index += dstIdx;
    input._index += srcIdx;
    return srcIdx == srcEnd;
}

bool TextCodec::expandDictionary()
{
    if (_dictSize >= MAX_DICT_SIZE)
        return false;

    DictEntry* newDict = new DictEntry[_dictSize * 2];
    memcpy(&newDict[0], &_dictList[0], sizeof(DictEntry) * _dictSize);

    for (int i = _dictSize; i < _dictSize * 2; i++)
        newDict[i] = DictEntry(nullptr, -1, 0, i, 0);

    delete[] _dictList;
    _dictList = newDict;

    // Reset map (values must point to addresses of new DictEntry items)
    for (int i = 0; i < _dictSize; i++) {
        _dictMap[_dictList[i]._hash & _hashMask] = &_dictList[i];
    }

    _dictSize <<= 1;
    return true;
}

int TextCodec::emitSymbols(byte src[], byte dst[], const int srcEnd, const int dstEnd)
{
    if (srcEnd == 0)
        return 0;

    return ((srcEnd << 2) < dstEnd) ? emitFast(src, dst, srcEnd, dstEnd) : emitSlow(src, dst, srcEnd, dstEnd);
}

int TextCodec::emitFast(byte src[], byte dst[], const int srcEnd, const int)
{
    // Fast path
    int dstIdx = 0;

    if ((src[0] == ESCAPE_TOKEN1) || (src[0] == ESCAPE_TOKEN2)) {
        // Emit special word
        const int idx = (src[0] == ESCAPE_TOKEN1) ? _staticDictSize - 1 : _staticDictSize - 2;
        dst[dstIdx++] = ESCAPE_TOKEN1;
        dstIdx += emitWordIndex(&dst[dstIdx], idx);
    }
    else {
        dst[dstIdx] = src[0];
        dstIdx++;
    }

    for (int i = 1; i < srcEnd; i++, dstIdx++) {
        dst[dstIdx] = src[i];
    }

    return dstIdx;
}

int TextCodec::emitSlow(byte src[], byte dst[], int const srcEnd, int const dstEnd)
{
    // Slow path
    int dstIdx = 0;

    for (int i = 0; i < srcEnd; i++) {
        const byte cur = src[i];

        if ((cur == ESCAPE_TOKEN1) || (cur == ESCAPE_TOKEN2)) {
            // Emit special word
            const int idx = (src[i] == ESCAPE_TOKEN1) ? _staticDictSize - 1 : _staticDictSize - 2;
            dst[dstIdx] = ESCAPE_TOKEN1;
            dstIdx++;

            if (idx >= THRESHOLD2) {
                if (dstIdx + 4 > dstEnd)
                    break;
            }
            else if (idx >= THRESHOLD1) {
                if (dstIdx + 3 > dstEnd)
                    break;
            }
            else {
                if (dstIdx + 2 > dstEnd)
                    break;
            }

            dstIdx += emitWordIndex(&dst[dstIdx], idx);
        }
        else {
            if (dstIdx >= dstEnd)
                break;

            dst[dstIdx++] = cur;
        }
    }

    return dstIdx;
}

int TextCodec::emitWordIndex(byte dst[], int val)
{
    int dstIdx = 0;

    // Emit word index (varint 5 bits + 7 bits + 7 bits)
    if (val >= THRESHOLD1) {
        if (val >= THRESHOLD2)
            dst[dstIdx++] = byte(0xE0 | (val >> 14));

        dst[dstIdx++] = byte(0x80 | (val >> 7));
        dst[dstIdx++] = byte(0x7F & val);
    }
    else {
        dst[dstIdx++] = byte(val);
    }

    return dstIdx;
}

bool TextCodec::sameWords(const byte src[], byte dst[], int length)
{
    if (length >= 4) {
        int32* p1 = (int32*) &dst[0];
        int32* p2 = (int32*) &src[0];

        while (length >= 4) {
            if (*p1++ != *p2++) {
                return false;
            }

            length -= 4;
        }
    }

    for (int i = 0, j = 0; i < length; i++, j++) {
        if (dst[i] != src[j]) {
            return false;
        }
    }

    return true;
}

bool TextCodec::inverse(SliceArray<byte>& input, SliceArray<byte>& output, int count)
{
    if ((!SliceArray<byte>::isValid(input)) || (!SliceArray<byte>::isValid(output)))
        return false;

    if (input._array == output._array)
        return false;

    byte* src = &input._array[input._index];
    byte* dst = &output._array[output._index];
    int srcIdx = 0;
    int dstIdx = 0;

    if (count <= 16) {
        for (int i = 0; i < count; i++)
            dst[dstIdx++] = src[srcIdx++];

        input._index += count;
        output._index += count;
        return true;
    }

    // Populate hash map
    const int32 mapSize = 1 << _logHashSize;

    for (int i = 0; i < mapSize; i++) {
        _dictMap[i] = nullptr;
    }

    for (int i = 0; i < _staticDictSize; i++) {
        _dictMap[_dictList[i]._hash & _hashMask] = &_dictList[i];
    }

    // Pre-allocate all dictionary entries
    for (int i = _staticDictSize; i < _dictSize; i++)
        _dictList[i] = DictEntry(nullptr, -1, 0, i, 0);

    const int srcEnd = count;
    const int dstEnd = output._length;
    int anchor = -1;
    int words = _staticDictSize;
    bool wordRun = false;

    while ((srcIdx < srcEnd) && (dstIdx < dstEnd)) {
        byte cur = src[srcIdx++];

        if (isText(cur)) {
            dst[dstIdx++] = cur;
            continue;
        }

        if ((srcIdx > anchor + 3) && ((cur == ESCAPE_TOKEN1) || (cur == ESCAPE_TOKEN2) || (isDelimiter(cur)))) // At least 2 letters
        {
            int length = srcIdx - anchor - 2;
            int h1 = HASH1;

            for (int i = 1; i <= length; i++)
                h1 = h1 * HASH1 ^ int32(src[anchor + i]) * HASH2;

            // Lookup word in dictionary
            DictEntry* pe = _dictMap[h1 & _hashMask];

            // Check for hash collisions
            if ((pe != nullptr) && ((pe->_length != length) || (pe->_hash != h1)))
                pe = nullptr;

            if (pe != nullptr) {
                if (!sameWords(&pe->_buf[pe->_pos + 1], &src[anchor + 2], length - 1))
                    pe = nullptr;
            }

            if (pe == nullptr) {
                // Word not found in the dictionary or hash collision: add or replace word
                if (((length > 3) || ((length > 2) && (words < THRESHOLD2))) && (length < MAX_WORD_LENGTH)) {
                    DictEntry& e = _dictList[words];

                    if (e._idx >= _staticDictSize) {
                        // Evict and reuse old entry
                        _dictMap[e._hash & _hashMask] = nullptr;
                        e._buf = src;
                        e._pos = anchor + 1;
                        e._hash = h1;
                        e._idx = int32(words);
                        e._length = int16(length);
                    }

                    _dictMap[h1 & _hashMask] = &e;
                    words++;

                    // Dictionary full ? Expand or reset index to end of static dictionary
                    if (words >= _dictSize) {
                        if (expandDictionary() == false)
                            words = _staticDictSize;
                    }
                }
            }
        }

        if ((cur == ESCAPE_TOKEN1) || (cur == ESCAPE_TOKEN2)) {
            // Word in dictionary
            // Read word index (varint 5 bits + 7 bits + 7 bits)
            int idx = src[srcIdx++] & 0xFF;

            if (idx >= 0x80) {
                idx &= 0x7F;
                int idx2 = src[srcIdx++] & 0xFF;

                if (idx2 >= 0x80) {
                    idx2 &= 0x7F;
                    idx &= 0x1F;
                    idx = (idx << 7) | idx2;
                    idx2 = src[srcIdx++] & 0x7F;
                }

                idx = (idx << 7) | idx2;

                if (idx >= _dictSize)
                    break;
            }

            DictEntry& e = _dictList[idx];

            // Sanity check
            if ((e._pos < 0) || (dstIdx + e._length >= dstEnd))
                break;

            // Add space if only delimiter between 2 words (not an escaped delimiter)
            if ((wordRun == true) && (e._length > 1))
                dst[dstIdx++] = ' ';

            int32 caseFlag = 0;

            // Flip case of first character
            if (cur == ESCAPE_TOKEN2)
                caseFlag = isUpperCase(e._buf[e._pos]) ? 32 : -32;

            dst[dstIdx++] = byte(e._buf[e._pos] + caseFlag);
            const byte* buf = &e._buf[e._pos];

            for (int n = 1, l = e._length; n < l; n++, dstIdx++)
                dst[dstIdx] = buf[n];

            if (e._length > 1) {
                // Regular word entry
                wordRun = true;
                anchor = srcIdx;
            }
            else {
                // Escape entry
                wordRun = false;
                anchor = srcIdx - 1;
            }
        }
        else {
            wordRun = false;
            anchor = srcIdx - 1;
            dst[dstIdx++] = cur;
        }
    }

    output._index += dstIdx;
    input._index += srcIdx;
    return srcIdx == srcEnd;
}

// Create dictionary from array of words
int TextCodec::createDictionary(SliceArray<byte> input, DictEntry dict[], int maxWords, int startWord)
{
    int anchor = 0;
    int32 h = HASH1;
    int nbWords = startWord;
    int dictSize = input._length;
    byte* words = input._array;

    for (int i = 0; ((i < dictSize) && (nbWords < maxWords)); i++) {
        byte cur = words[i];

        if (isText(cur)) {
            h = h * HASH1 ^ int(cur) * HASH2;
            continue;
        }

        if ((isDelimiter(cur)) && (nbWords < maxWords) && (i >= anchor + 1)) { // At least 2 letters
            dict[nbWords] = DictEntry(words, anchor, h, nbWords, i - anchor);
            nbWords++;
        }

        anchor = i + 1;
        h = HASH1;
    }

    return nbWords;
}

// Unpack dictionary with 32 symbols (all lowercase except first word char)
SliceArray<byte> TextCodec::unpackDictionary32(const byte dict[], int dictSize)
{
    byte* buf = new byte[dictSize * 2];
    int d = 0;
    int val = 0;

    // Unpack 3 bytes into 4 6-bit symbols
    for (int i = 0; i < dictSize; i++) {
        val = (val << 8) | (dict[i] & 0xFF);

        if ((i % 3) == 2) {
            for (int ii = 18; ii >= 0; ii -= 6) {
                int c = (val >> ii) & 0x3F;

                if (c >= 32)
                    buf[d++] = ' ';

                c &= 0x1F;

                // Ignore padding symbols (> 26 and <= 31)
                if (c <= 26)
                    buf[d++] = byte(c + 'a');
            }

            val = 0;
        }
    }

    buf[d] = ' '; // End
    byte* res = new byte[d];
    memcpy(&res[0], &buf[1], d);
    delete[] buf;
    return SliceArray<byte>(res, d, 0);
}
